const hollowObject = {
  "points":[
      [-5,-4,-4],
      [-4,-4,-4],
      [-4,4,-4],
      [-5,4,-4],
      [-4,4,-5],
      [-4,4,-4],
      [-4,-4,-4],
      [-4,-4,-5],
      [-5,-5,-5],
      [-5,-4,-4],
      [-5,4,-4],
      [-5,5,-5],
      [-5,5,-5],
      [-4,4,-5],
      [-4,-4,-5],
      [-5,-5,-5],
      [5,4,-4],
      [4,4,-4],
      [4,-4,-4],
      [5,-4,-4],
      [4,-4,-5],
      [4,-4,-4],
      [4,4,-4],
      [4,4,-5],
      [5,5,-5],
      [5,4,-4],
      [5,-4,-4],
      [5,-5,-5],
      [5,-5,-5],
      [4,-4,-5],
      [4,4,-5],
      [5,5,-5],
      [-5,4,4],
      [-4,4,4],
      [-4,-4,4],
      [-5,-4,4],
      [-4,-4,5],
      [-4,-4,4],
      [-4,4,4],
      [-4,4,5],
      [-5,5,5],
      [-5,4,4],
      [-5,-4,4],
      [-5,-5,5],
      [-5,-5,5],
      [-4,-4,5],
      [-4,4,5],
      [-5,5,5],
      [5,-4,4],
      [4,-4,4],
      [4,4,4],
      [5,4,4],
      [4,4,5],
      [4,4,4],
      [4,-4,4],
      [4,-4,5],
      [5,-5,5],
      [5,-4,4],
      [5,4,4],
      [5,5,5],
      [5,5,5],
      [4,4,5],
      [4,-4,5],
      [5,-5,5],
      [4,-5,-4],
      [4,-4,-4],
      [-4,-4,-4],
      [-4,-5,-4],
      [-4,-4,-5],
      [-4,-4,-4],
      [4,-4,-4],
      [4,-4,-5],
      [5,-5,-5],
      [4,-5,-4],
      [-4,-5,-4],
      [-5,-5,-5],
      [-5,-5,-5],
      [-4,-4,-5],
      [4,-4,-5],
      [5,-5,-5],
      [-4,5,-4],
      [-4,4,-4],
      [4,4,-4],
      [4,5,-4],
      [4,4,-5],
      [4,4,-4],
      [-4,4,-4],
      [-4,4,-5],
      [-5,5,-5],
      [-4,5,-4],
      [4,5,-4],
      [5,5,-5],
      [5,5,-5],
      [4,4,-5],
      [-4,4,-5],
      [-5,5,-5],
      [-4,-5,4],
      [-4,-4,4],
      [4,-4,4],
      [4,-5,4],
      [4,-4,5],
      [4,-4,4],
      [-4,-4,4],
      [-4,-4,5],
      [-5,-5,5],
      [-4,-5,4],
      [4,-5,4],
      [5,-5,5],
      [5,-5,5],
      [4,-4,5],
      [-4,-4,5],
      [-5,-5,5],
      [4,5,4],
      [4,4,4],
      [-4,4,4],
      [-4,5,4],
      [-4,4,5],
      [-4,4,4],
      [4,4,4],
      [4,4,5],
      [5,5,5],
      [4,5,4],
      [-4,5,4],
      [-5,5,5],
      [-5,5,5],
      [-4,4,5],
      [4,4,5],
      [5,5,5],
      [-5,4,-4],
      [-4,4,-4],
      [-4,4,4],
      [-5,4,4],
      [-4,5,4],
      [-4,4,4],
      [-4,4,-4],
      [-4,5,-4],
      [-5,5,-5],
      [-5,4,-4],
      [-5,4,4],
      [-5,5,5],
      [-5,5,5],
      [-4,5,4],
      [-4,5,-4],
      [-5,5,-5],
      [5,4,4],
      [4,4,4],
      [4,4,-4],
      [5,4,-4],
      [4,5,-4],
      [4,4,-4],
      [4,4,4],
      [4,5,4],
      [5,5,5],
      [5,4,4],
      [5,4,-4],
      [5,5,-5],
      [5,5,-5],
      [4,5,-4],
      [4,5,4],
      [5,5,5],
      [-5,-4,4],
      [-4,-4,4],
      [-4,-4,-4],
      [-5,-4,-4],
      [-4,-5,-4],
      [-4,-4,-4],
      [-4,-4,4],
      [-4,-5,4],
      [-5,-5,5],
      [-5,-4,4],
      [-5,-4,-4],
      [-5,-5,-5],
      [-5,-5,-5],
      [-4,-5,-4],
      [-4,-5,4],
      [-5,-5,5],
      [5,-4,-4],
      [4,-4,-4],
      [4,-4,4],
      [5,-4,4],
      [4,-5,4],
      [4,-4,4],
      [4,-4,-4],
      [4,-5,-4],
      [5,-5,-5],
      [5,-4,-4],
      [5,-4,4],
      [5,-5,5],
      [5,-5,5],
      [4,-5,4],
      [4,-5,-4],
      [5,-5,-5]
  ],
  "rusuk":[
      {
          "topologi":[
              [0,1,2,3],
              [4,5,6,7],
              [8,9,10,11],
              [12,13,14,15]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [16,17,18,19],
              [20,21,22,23],
              [24,25,26,27],
              [28,29,30,31]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [32,33,34,35],
              [36,37,38,39],
              [40,41,42,43],
              [44,45,46,47]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [48,49,50,51],
              [52,53,54,55],
              [56,57,58,59],
              [60,61,62,63]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [64,65,66,67],
              [68,69,70,71],
              [72,73,74,75],
              [76,77,78,79]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [80,81,82,83],
              [84,85,86,87],
              [88,89,90,91],
              [92,93,94,95]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [96,97,98,99],
              [100,101,102,103],
              [104,105,106,107],
              [108,109,110,111]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [112,113,114,115],
              [116,117,118,119],
              [120,121,122,123],
              [124,125,126,127]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [128,129,130,131],
              [132,133,134,135],
              [136,137,138,139],
              [140,141,142,143]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [144,145,146,147],
              [148,149,150,151],
              [152,153,154,155],
              [156,157,158,159]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [160,161,162,163],
              [164,165,166,167],
              [168,169,170,171],
              [172,173,174,175]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      },
      {
          "topologi":[
              [176,177,178,179],
              [180,181,182,183],
              [184,185,186,187],
              [188,189,190,191]
          ],
          "color":[
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1],
              [1,0.6,0.9,1]
          ]
      }
  ],
  "slider": [
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1
  ],
  "projection" : "orthographic",
  "shading" : false,
  "rotate" : 0,
  "animation" : false
}

var vertices = [];
// var hollowObject;
var colors = [];
var translation = [0, 0, 0];
var rotation = [degToRad(0), degToRad(0), degToRad(0)];
var scale = [1, 1, 1];
var projectionMode = "orthographic";
var shadingEnabled = false;
var animationActive = false;
var rotateX = 0;
var rotateY = 0;
var rotateZ = 0;
var rotateAxis = 0;
var reqAnime = null;
var cameraAngleRadians = degToRad(0);
var cameraRadius = 20;
var cameraTarget = [0, 0, 0];
var cameraPosition = [0, 0, -5];

var fieldOfView = (60 * Math.PI) / 180; // in radians
var zNear = 1;
var zFar = 2000;
var left = -10;
var right = 10;
var bottom = -10;
var topFov = 10;
var near = -100;
var far = 100;
var up = [0, 1, 0];


// Initialize the WebGL context
var canvas = document.querySelector("#gl-canvas");
var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
if (!gl) {
  alert("WebGL not available");
}
const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;

// Create, upload, and compile the shaders
var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

// Link the two shaders above into a program
var program = createProgram(gl, vertexShader, fragmentShader);

gl.useProgram(program);

var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
var resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
var colorUniformLocation = gl.getUniformLocation(program, "u_color");
var colorAttributeLocation = gl.getAttribLocation(program, "a_color");
var matrixLocation = gl.getUniformLocation(program, "u_matrix");

// Set viewport
gl.viewport(0, 0, canvas.width, canvas.height);

const updateAngleX = () => {
  var angleX = document.getElementById("angleX").value;
  rotation[0] = degToRad(angleX);
  document.getElementById("angleX-value").innerHTML = angleX;
  drawScene();
};

const updateAngleY = () => {
  var angleY = document.getElementById("angleY").value;
  rotation[1] = degToRad(angleY);
  document.getElementById("angleY-value").innerHTML = angleY;
  drawScene();
};

const updateAngleZ = () => {
  var angleZ = document.getElementById("angleZ").value;
  rotation[2] = degToRad(angleZ);
  document.getElementById("angleZ-value").innerHTML = angleZ;
  drawScene();
};

const updateScaleX = () => {
  var scaleX = document.getElementById("scaleX").value;
  scale[0] = scaleX;
  document.getElementById("scaleX-value").innerHTML = scaleX;
  drawScene();
};

const updateScaleY = () => {
  var scaleY = document.getElementById("scaleY").value;
  scale[1] = scaleY;
  document.getElementById("scaleY-value").innerHTML = scaleY;
  drawScene();
};

const updateScaleZ = () => {
  var scaleZ = document.getElementById("scaleZ").value;
  scale[2] = scaleZ;
  document.getElementById("scaleZ-value").innerHTML = scaleZ;
  drawScene();
};

const updateTranslateX = () => {
  var translateX = parseFloat(document.getElementById("translateX").value);
  // translation[0] = toCanvasX(canvas, translateX, 10);
  translation[0] = translateX;
  document.getElementById("translateX-value").innerHTML = translateX;
  drawScene();
};

const updateTranslateY = () => {
  var translateY = parseFloat(document.getElementById("translateY").value);
  // translation[1] = toCanvasY(canvas, translateY, 10);
  translation[1] = translateY;
  document.getElementById("translateY-value").innerHTML = translateY;
  drawScene();
};

const updateTranslateZ = () => {
  var translateZ = parseFloat(document.getElementById("translateZ").value);
  // translation[2] = toCanvasZ(translateZ, 10);
  translation[2] = translateZ;
  // console.log(translation[2]);
  document.getElementById("translateZ-value").innerHTML = translateZ;
  drawScene();
};

const updateCameraX = () => {
  var cameraX = parseFloat(document.getElementById("cameraX").value);
  cameraPosition[0] = cameraX;
  document.getElementById("cameraX-value").innerHTML = cameraX;
  drawScene();
}

const updateCameraY = () => {
  var cameraY = parseFloat(document.getElementById("cameraY").value);
  cameraPosition[1] = cameraY;
  document.getElementById("cameraY-value").innerHTML = cameraY;
  drawScene();
}

const updateCameraZ = () => {
  var cameraZ = parseFloat(document.getElementById("cameraZ").value);
  cameraPosition[2] = cameraZ;
  document.getElementById("cameraZ-value").innerHTML = cameraZ;
  drawScene();
}

const updateCameraRadius = () => {
  var cameraRadiusTemp = parseFloat(document.getElementById("cameraRadius").value);
  cameraRadius = cameraRadiusTemp;
  document.getElementById("cameraRadius-value").innerHTML = cameraRadius;
  drawScene();
}

const updateProjectionMode = () => {
  projectionMode = document.getElementById("projection-type").value;
  console.log(projectionMode);
  drawScene();
};

const toggleShading = () => {
  shadingEnabled = !shadingEnabled;
  var text = shadingEnabled ? "On" : "Off";
  document.getElementById("shading-label").innerHTML = text;
  drawScene();
};

const toggleAnimation = () => {
  animationActive = !animationActive;
  var text = animationActive ? "On" : "Off";
  document.getElementById("animation-label").innerHTML = text;
  drawScene();
};

const rotateToX = () => {
  rotateAxis = 0;
};

const rotateToY = () => {
  rotateAxis = 1;
};

const rotateToZ = () => {
  rotateAxis = 2;
};

function render(vertice, color) {
  var buffer = gl.createBuffer();
  // var obj = loadObject();

  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertice), gl.STATIC_DRAW);
  gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(positionAttributeLocation);

  var faceColors = [];
  for (var j = 0; j < color.length; ++j) {
    const c = color[j];
    for (var i = 0; i < 4; ++i) {
      faceColors = faceColors.concat(c);
    }
  }

  var colorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(faceColors), gl.STATIC_DRAW);
  gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(colorAttributeLocation);

  const indicesBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
  gl.bufferData(
    gl.ELEMENT_ARRAY_BUFFER,
    new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3, // front
      4,
      5,
      6,
      4,
      6,
      7, // back
      8,
      9,
      10,
      8,
      10,
      11, // top
      12,
      13,
      14,
      12,
      14,
      15, // bottom
      16,
      17,
      18,
      16,
      18,
      19, // right
      20,
      21,
      22,
      20,
      22,
      23, // left
    ]),
    gl.STATIC_DRAW
  );
}

function loadObject() {
  let vertice = hollowObject.points;
  let vertexSorted = [];
  let colorSorted = [];
  for (let i = 0; i < hollowObject.rusuk.length; i++) {
    let point = hollowObject.rusuk[i];
    let tmpColor = [];
    let position = [];
    for (let j = 0; j < point.topologi.length; j++) {
      position = position.concat(vertice[point.topologi[j][0]]);
      position = position.concat(vertice[point.topologi[j][1]]);
      position = position.concat(vertice[point.topologi[j][2]]);
      position = position.concat(vertice[point.topologi[j][3]]);
      tmpColor.push(point.color[j]);
    }
    colorSorted.push(tmpColor);
    vertexSorted.push(position);
  }
  vertices = vertexSorted;
  colors = colorSorted;
  updateData();
  drawScene();
}

function onChange(event) {
  var reader = new FileReader();
  reader.onload = onReaderLoad;
  reader.readAsText(event.target.files[0]);
}

function onReaderLoad(event) {
  hollowObject = JSON.parse(event.target.result);
  loadObject();
}

document.getElementById("load").addEventListener("change", onChange);

function drawScene() {
  if (reqAnime) {
    cancelAnimationFrame(reqAnime);
  }
  // Clear the canvas
  gl.clearColor(0, 0, 0, 0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // Draw a rectangle
  gl.enable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  for (let i = 0; i < vertices.length; i++) {
    var count = vertices[i].length / 2;
    render(vertices[i], colors[i]);
    var matrix = m4.identity();
    // var projectionMatrix = m4.projection(gl.canvas.clientWidth, gl.canvas.clientHeight, 400);

    // var cameraMatrix = m4.yRotation(cameraAngleRadians);
    // cameraMatrix = m4.translate(cameraMatrix, 0, 0, cameraRadius * 1.5);
    // cameraPosition = [cameraMatrix[12], cameraMatrix[13], cameraMatrix[14]];

    // cameraMatrix = m4.lookAt(cameraPosition, cameraTarget, up);
    // var viewMatrix = m4.inverse(cameraMatrix);


    var cameraMatrix = m4.identity();
    var zoom = cameraRadius / 20;
    cameraMatrix = m4.lookAt(cameraPosition, cameraTarget, up, zoom);
    
    var viewMatrix = m4.inverse(cameraMatrix);
    console.log(viewMatrix)
    // console.log(cameraMatrix)
    var projectionMatrix = m4.identity();
    // console.log(viewMatrix)


    if (projectionMode == "orthographic") {
      projectionMatrix = m4.orthographic(left, right, bottom, topFov, near, far);
    } else if (projectionMode == "perspective") {
      projectionMatrix = m4.perspective(fieldOfView, aspect, zNear, zFar);
    } else if (projectionMode == "oblique") {
    }

    matrix = m4.translate(
      matrix,
      translation[0],
      translation[1],
      translation[2]
    );
    matrix = m4.xRotate(matrix, rotation[0]);
    matrix = m4.yRotate(matrix, rotation[1]);
    matrix = m4.zRotate(matrix, rotation[2]);
    matrix = m4.scale(matrix, scale[0], scale[1], scale[2]);

    matrix = m4.multiply(viewMatrix, matrix);
    matrix = m4.multiply(projectionMatrix, matrix);
    // matrix = m4.multiply(projectionMatrix, matrix);



    gl.uniformMatrix4fv(matrixLocation, false, matrix);
    gl.drawElements(this.gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0);
  }
  if (animationActive) {
    if (rotateAxis == 0) {
      if (rotateX == 360 ) {
        rotateX = 0;
      }
      rotateX+=1;
      rotation[0] = degToRad(rotateX);
    }
    else if (rotateAxis == 1) {
      if (rotateY == 360 ) {
        rotateY = 0;
      }
      rotateY+=1;
      rotation[1] = degToRad(rotateY);
    }
    else {
      if (rotateZ == 360 ) {
        rotateZ = 0;
      }
      rotateZ+=1;
      rotation[2] = degToRad(rotateZ);
    }
    reqAnime = requestAnimationFrame(drawScene);
}
}

function resetDefault() {
  rotation = [0, 0, 0];
  scale = [1, 1, 1];
  translation = [0, 0, 0];
  cameraPosition = [0, 0, 5];
  document.getElementById("angleX").value = 0;
  document.getElementById("angleY").value = 0;
  document.getElementById("angleZ").value = 0;
  document.getElementById("scaleX").value = 1;
  document.getElementById("scaleY").value = 1;
  document.getElementById("scaleZ").value = 1;
  document.getElementById("translateX").value = 0;
  document.getElementById("translateY").value = 0;
  document.getElementById("translateZ").value = 0;
  document.getElementById("cameraX").value = 0;
  document.getElementById("cameraY").value = 0;
  document.getElementById("cameraZ").value = 5;
  document.getElementById("cameraRadius").value = 20;
  document.getElementById("angleX-value").innerHTML = 0;
  document.getElementById("angleY-value").innerHTML = 0;
  document.getElementById("angleZ-value").innerHTML = 0;
  document.getElementById("scaleX-value").innerHTML = 1;
  document.getElementById("scaleY-value").innerHTML = 1;
  document.getElementById("scaleZ-value").innerHTML = 1;
  document.getElementById("translateX-value").innerHTML = 0;
  document.getElementById("translateY-value").innerHTML = 0;
  document.getElementById("translateZ-value").innerHTML = 0;
  document.getElementById("cameraX-value").innerHTML = 0;
  document.getElementById("cameraY-value").innerHTML = 0;
  document.getElementById("cameraZ-value").innerHTML = 5;
  document.getElementById("cameraRadius-value").innerHTML = 20;

  drawScene();
}

function updateData() {
  let data = hollowObject.slider
  document.getElementById("angleX").value = data[0];
  document.getElementById("angleY").value = data[1];
  document.getElementById("angleZ").value = data[2];
  document.getElementById("angleX-value").innerHTML = data[0];
  document.getElementById("angleY-value").innerHTML = data[1];
  document.getElementById("angleZ-value").innerHTML = data[2];
  rotation[0] = degToRad(data[0]);
  rotation[1] = degToRad(data[1]);
  rotation[2] = degToRad(data[2]);

  document.getElementById("translateX-value").innerHTML = data[3];
  document.getElementById("translateY-value").innerHTML = data[4];
  document.getElementById("translateZ-value").innerHTML = data[5];
  
  document.getElementById("translateX").value = data[3];
  document.getElementById("translateY").value = data[4];
  document.getElementById("translateZ").value = data[5];
  translation[0] = data[3];
  translation[1] = data[4];
  translation[2] = data[5];

  document.getElementById("scaleX").value = data[6]; 
  document.getElementById("scaleY").value = data[7];
  document.getElementById("scaleZ").value = data[8];
  document.getElementById("scaleX-value").innerHTML = data[6];
  document.getElementById("scaleY-value").innerHTML = data[7];
  document.getElementById("scaleZ-value").innerHTML = data[8];
  scale[0] = data[6];
  scale[1] = data[7];
  scale[2] = data[8];

  document.querySelector('#projection-type').value = hollowObject.projection;
  projectionMode = hollowObject.projection;

  rotateAxis = hollowObject.rotateAxis;

  shadingEnabled = hollowObject.shading;
  var textShading = shadingEnabled ? "On" : "Off";
  document.getElementById("shading-label").innerHTML = textShading;

  animationActive = hollowObject.animation;
  var textAnime = animationActive ? "On" : "Off";
  document.getElementById("shading-label").innerHTML = textAnime;
}

function saveModel() {
  let rx, ry, rz;
  rx = document.getElementById("angleX").value;
  ry = document.getElementById("angleY").value;
  rz = document.getElementById("angleZ").value;
  hollowObject.slider = [rx, ry, rz, translation[0], translation[1], translation[2], scale[0], scale[1], scale[2]];
  hollowObject.projection = projectionMode;
  hollowObject.rotateAxis = rotateAxis;
  hollowObject.shading = shadingEnabled;
  hollowObject.animation = animationActive;

  let data = JSON.stringify(hollowObject);
  download("model.json", 'text/plain', data);
}

function download(fileName, contentType, content) {
  var a = document.createElement("a");
  var file = new Blob([content], {type: contentType});
  a.href = URL.createObjectURL(file);
  a.download = fileName;
  a.click();
}
loadObject();
